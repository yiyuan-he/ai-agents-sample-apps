"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.attributeMatch = exports.wildcardMatch = exports.CLOUD_PLATFORM_MAPPING = void 0;
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
exports.CLOUD_PLATFORM_MAPPING = {
    [semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_LAMBDA]: 'AWS::Lambda::Function',
    [semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK]: 'AWS::ElasticBeanstalk::Environment',
    [semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_EC2]: 'AWS::EC2::Instance',
    [semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_ECS]: 'AWS::ECS::Container',
    [semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_EKS]: 'AWS::EKS::Container',
};
// Template function from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping
function escapeRegExp(regExPattern) {
    // removed * and ? so they don't get escaped to maintain them as a wildcard match
    return regExPattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
}
function convertPatternToRegExp(pattern) {
    return escapeRegExp(pattern).replace(/\*/g, '.*').replace(/\?/g, '.');
}
function wildcardMatch(pattern, text) {
    if (pattern === '*')
        return true;
    if (pattern === undefined || typeof text !== 'string')
        return false;
    if (pattern.length === 0)
        return text.length === 0;
    const match = text.toLowerCase().match(`^${convertPatternToRegExp(pattern.toLowerCase())}$`);
    if (match === null) {
        api_1.diag.debug(`WildcardMatch: no match found for ${text} against pattern ${pattern}`);
        return false;
    }
    return true;
}
exports.wildcardMatch = wildcardMatch;
function attributeMatch(attributes, ruleAttributes) {
    if (!ruleAttributes || Object.keys(ruleAttributes).length === 0) {
        return true;
    }
    if (attributes === undefined ||
        Object.keys(attributes).length === 0 ||
        Object.keys(ruleAttributes).length > Object.keys(attributes).length) {
        return false;
    }
    let matchedCount = 0;
    for (const [key, value] of Object.entries(attributes)) {
        const foundKey = Object.keys(ruleAttributes).find(ruleKey => ruleKey === key);
        if (foundKey === undefined) {
            continue;
        }
        if (wildcardMatch(ruleAttributes[foundKey], value)) {
            // increment matched count
            matchedCount += 1;
        }
    }
    return matchedCount === Object.keys(ruleAttributes).length;
}
exports.attributeMatch = attributeMatch;
//# sourceMappingURL=utils.js.map