{"version":3,"file":"rule-cache.js","sourceRoot":"","sources":["../../../src/sampler/rule-cache.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Attributes, diag } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport {\n  ISamplingStatistics,\n  SamplingStatisticsDocument,\n  SamplingTargetDocument,\n  TargetMap,\n} from './remote-sampler.types';\nimport { SamplingRuleApplier } from './sampling-rule-applier';\n\n// The cache expires 1 hour after the last refresh time.\nconst RULE_CACHE_TTL_MILLIS: number = 60 * 60 * 1000;\n\n// 10 second default sampling targets polling interval\nexport const DEFAULT_TARGET_POLLING_INTERVAL_SECONDS: number = 10;\n\nexport class RuleCache {\n  private ruleAppliers: SamplingRuleApplier[];\n  private lastUpdatedEpochMillis: number;\n  private samplerResource: Resource;\n\n  constructor(samplerResource: Resource) {\n    this.ruleAppliers = [];\n    this.samplerResource = samplerResource;\n    this.lastUpdatedEpochMillis = Date.now();\n  }\n\n  public isExpired(): boolean {\n    const nowInMillis: number = Date.now();\n    return nowInMillis > this.lastUpdatedEpochMillis + RULE_CACHE_TTL_MILLIS;\n  }\n\n  public getMatchedRule(attributes: Attributes): SamplingRuleApplier | undefined {\n    return this.ruleAppliers.find(\n      rule => rule.matches(attributes, this.samplerResource) || rule.samplingRule.RuleName === 'Default'\n    );\n  }\n\n  private sortRulesByPriority(): void {\n    this.ruleAppliers.sort((rule1: SamplingRuleApplier, rule2: SamplingRuleApplier): number => {\n      if (rule1.samplingRule.Priority === rule2.samplingRule.Priority) {\n        return rule1.samplingRule.RuleName < rule2.samplingRule.RuleName ? -1 : 1;\n      }\n      return rule1.samplingRule.Priority - rule2.samplingRule.Priority;\n    });\n  }\n\n  public updateRules(newRuleAppliers: SamplingRuleApplier[]): void {\n    const oldRuleAppliersMap: { [key: string]: SamplingRuleApplier } = {};\n\n    this.ruleAppliers.forEach((rule: SamplingRuleApplier) => {\n      oldRuleAppliersMap[rule.samplingRule.RuleName] = rule;\n    });\n\n    newRuleAppliers.forEach((newRule: SamplingRuleApplier, index: number) => {\n      const ruleNameToCheck: string = newRule.samplingRule.RuleName;\n      if (ruleNameToCheck in oldRuleAppliersMap) {\n        const oldRule: SamplingRuleApplier = oldRuleAppliersMap[ruleNameToCheck];\n        if (newRule.samplingRule.equals(oldRule.samplingRule)) {\n          newRuleAppliers[index] = oldRule;\n        }\n      }\n    });\n    this.ruleAppliers = newRuleAppliers;\n\n    // sort ruleAppliers by priority and update lastUpdatedEpochMillis\n    this.sortRulesByPriority();\n    this.lastUpdatedEpochMillis = Date.now();\n  }\n\n  public createSamplingStatisticsDocuments(clientId: string): SamplingStatisticsDocument[] {\n    const statisticsDocuments: SamplingStatisticsDocument[] = [];\n\n    this.ruleAppliers.forEach((rule: SamplingRuleApplier) => {\n      const statistics: ISamplingStatistics = rule.snapshotStatistics();\n      const nowInSeconds: number = Math.floor(Date.now() / 1000);\n\n      const samplingStatisticsDoc: SamplingStatisticsDocument = {\n        ClientID: clientId,\n        RuleName: rule.samplingRule.RuleName,\n        Timestamp: nowInSeconds,\n        RequestCount: statistics.RequestCount,\n        BorrowCount: statistics.BorrowCount,\n        SampledCount: statistics.SampleCount,\n      };\n\n      statisticsDocuments.push(samplingStatisticsDoc);\n    });\n    return statisticsDocuments;\n  }\n\n  // Update ruleAppliers based on the targets fetched from X-Ray service\n  public updateTargets(targetDocuments: TargetMap, lastRuleModification: number): [boolean, number] {\n    let minPollingInteral: number | undefined = undefined;\n    let nextPollingInterval: number = DEFAULT_TARGET_POLLING_INTERVAL_SECONDS;\n    this.ruleAppliers.forEach((rule: SamplingRuleApplier, index: number) => {\n      const target: SamplingTargetDocument = targetDocuments[rule.samplingRule.RuleName];\n      if (target) {\n        this.ruleAppliers[index] = rule.withTarget(target);\n        if (target.Interval) {\n          if (minPollingInteral === undefined || minPollingInteral > target.Interval) {\n            minPollingInteral = target.Interval;\n          }\n        }\n      } else {\n        diag.debug('Invalid sampling target: missing rule name');\n      }\n    });\n\n    if (minPollingInteral) {\n      nextPollingInterval = minPollingInteral;\n    }\n\n    const refreshSamplingRules: boolean = lastRuleModification * 1000 > this.lastUpdatedEpochMillis;\n    return [refreshSamplingRules, nextPollingInterval];\n  }\n}\n"]}