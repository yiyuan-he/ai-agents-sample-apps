"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleCache = exports.DEFAULT_TARGET_POLLING_INTERVAL_SECONDS = void 0;
const api_1 = require("@opentelemetry/api");
// The cache expires 1 hour after the last refresh time.
const RULE_CACHE_TTL_MILLIS = 60 * 60 * 1000;
// 10 second default sampling targets polling interval
exports.DEFAULT_TARGET_POLLING_INTERVAL_SECONDS = 10;
class RuleCache {
    constructor(samplerResource) {
        this.ruleAppliers = [];
        this.samplerResource = samplerResource;
        this.lastUpdatedEpochMillis = Date.now();
    }
    isExpired() {
        const nowInMillis = Date.now();
        return nowInMillis > this.lastUpdatedEpochMillis + RULE_CACHE_TTL_MILLIS;
    }
    getMatchedRule(attributes) {
        return this.ruleAppliers.find(rule => rule.matches(attributes, this.samplerResource) || rule.samplingRule.RuleName === 'Default');
    }
    sortRulesByPriority() {
        this.ruleAppliers.sort((rule1, rule2) => {
            if (rule1.samplingRule.Priority === rule2.samplingRule.Priority) {
                return rule1.samplingRule.RuleName < rule2.samplingRule.RuleName ? -1 : 1;
            }
            return rule1.samplingRule.Priority - rule2.samplingRule.Priority;
        });
    }
    updateRules(newRuleAppliers) {
        const oldRuleAppliersMap = {};
        this.ruleAppliers.forEach((rule) => {
            oldRuleAppliersMap[rule.samplingRule.RuleName] = rule;
        });
        newRuleAppliers.forEach((newRule, index) => {
            const ruleNameToCheck = newRule.samplingRule.RuleName;
            if (ruleNameToCheck in oldRuleAppliersMap) {
                const oldRule = oldRuleAppliersMap[ruleNameToCheck];
                if (newRule.samplingRule.equals(oldRule.samplingRule)) {
                    newRuleAppliers[index] = oldRule;
                }
            }
        });
        this.ruleAppliers = newRuleAppliers;
        // sort ruleAppliers by priority and update lastUpdatedEpochMillis
        this.sortRulesByPriority();
        this.lastUpdatedEpochMillis = Date.now();
    }
    createSamplingStatisticsDocuments(clientId) {
        const statisticsDocuments = [];
        this.ruleAppliers.forEach((rule) => {
            const statistics = rule.snapshotStatistics();
            const nowInSeconds = Math.floor(Date.now() / 1000);
            const samplingStatisticsDoc = {
                ClientID: clientId,
                RuleName: rule.samplingRule.RuleName,
                Timestamp: nowInSeconds,
                RequestCount: statistics.RequestCount,
                BorrowCount: statistics.BorrowCount,
                SampledCount: statistics.SampleCount,
            };
            statisticsDocuments.push(samplingStatisticsDoc);
        });
        return statisticsDocuments;
    }
    // Update ruleAppliers based on the targets fetched from X-Ray service
    updateTargets(targetDocuments, lastRuleModification) {
        let minPollingInteral = undefined;
        let nextPollingInterval = exports.DEFAULT_TARGET_POLLING_INTERVAL_SECONDS;
        this.ruleAppliers.forEach((rule, index) => {
            const target = targetDocuments[rule.samplingRule.RuleName];
            if (target) {
                this.ruleAppliers[index] = rule.withTarget(target);
                if (target.Interval) {
                    if (minPollingInteral === undefined || minPollingInteral > target.Interval) {
                        minPollingInteral = target.Interval;
                    }
                }
            }
            else {
                api_1.diag.debug('Invalid sampling target: missing rule name');
            }
        });
        if (minPollingInteral) {
            nextPollingInterval = minPollingInteral;
        }
        const refreshSamplingRules = lastRuleModification * 1000 > this.lastUpdatedEpochMillis;
        return [refreshSamplingRules, nextPollingInterval];
    }
}
exports.RuleCache = RuleCache;
//# sourceMappingURL=rule-cache.js.map