{"version":3,"file":"aws-span-metrics-processor.js","sourceRoot":"","sources":["../../src/aws-span-metrics-processor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AttributeValue, Attributes, Context, Histogram, SpanStatusCode } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport { ReadableSpan, Span, SpanProcessor } from '@opentelemetry/sdk-trace-base';\nimport { SEMATTRS_HTTP_STATUS_CODE } from '@opentelemetry/semantic-conventions';\nimport { AttributeMap, MetricAttributeGenerator } from './metric-attribute-generator';\nimport { ForceFlushFunction } from './aws-span-processing-util';\nimport { AWS_ATTRIBUTE_KEYS } from './aws-attribute-keys';\n\n/**\n * This processor will generate metrics based on span data. It depends on a\n * {@link MetricAttributeGenerator} being provided on instantiation, which will provide a means to\n * determine attributes which should be used to create metrics. A {@link Resource} must also be\n * provided, which is used to generate metrics. Finally, three {@link Histogram}'s must be provided,\n * which will be used to actually create desired metrics (see below)\n *\n * <p>AwsSpanMetricsProcessor produces metrics for errors (e.g. HTTP 4XX status codes), faults (e.g.\n * HTTP 5XX status codes), and latency (in Milliseconds). Errors and faults are counted, while\n * latency is measured with a histogram. Metrics are emitted with attributes derived from span\n * attributes.\n *\n * <p>For highest fidelity metrics, this processor should be coupled with the {@link AlwaysRecordSampler},\n * which will result in 100% of spans being sent to the processor.\n */\nexport class AwsSpanMetricsProcessor implements SpanProcessor {\n  private NANOS_TO_MILLIS_DIVIDER: number = 1_000_000.0;\n  private SECONDS_TO_MILLIS_MULTIPLIER: number = 1_000.0;\n\n  // Constants for deriving error and fault metrics\n  private ERROR_CODE_LOWER_BOUND: number = 400;\n  private ERROR_CODE_UPPER_BOUND: number = 499;\n  private FAULT_CODE_LOWER_BOUND: number = 500;\n  private FAULT_CODE_UPPER_BOUND: number = 599;\n\n  // EC2 Metadata API IP Address\n  // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html#instancedata-inside-access\n  private EC2_METADATA_API_IP: string = '169.254.169.254';\n\n  // Metric instruments\n  private errorHistogram: Histogram;\n  private faultHistogram: Histogram;\n  private latencyHistogram: Histogram;\n\n  private generator: MetricAttributeGenerator;\n  private resource: Resource;\n  private forceFlushFunction: ForceFlushFunction;\n\n  /** Use {@link AwsSpanMetricsProcessorBuilder} to construct this processor. */\n  static create(\n    errorHistogram: Histogram,\n    faultHistogram: Histogram,\n    latencyHistogram: Histogram,\n    generator: MetricAttributeGenerator,\n    resource: Resource,\n    forceFlushFunction: ForceFlushFunction\n  ): AwsSpanMetricsProcessor {\n    return new AwsSpanMetricsProcessor(\n      errorHistogram,\n      faultHistogram,\n      latencyHistogram,\n      generator,\n      resource,\n      forceFlushFunction\n    );\n  }\n\n  private constructor(\n    errorHistogram: Histogram,\n    faultHistogram: Histogram,\n    latencyHistogram: Histogram,\n    generator: MetricAttributeGenerator,\n    resource: Resource,\n    forceFlushFunction: ForceFlushFunction\n  ) {\n    this.errorHistogram = errorHistogram;\n    this.faultHistogram = faultHistogram;\n    this.latencyHistogram = latencyHistogram;\n    this.generator = generator;\n    this.resource = resource;\n    this.forceFlushFunction = forceFlushFunction;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public onStart(span: Span, parentContext: Context): void {}\n\n  public onEnd(span: ReadableSpan): void {\n    const attributeMap: AttributeMap = this.generator.generateMetricAttributeMapFromSpan(span, this.resource);\n\n    for (const attribute in attributeMap) {\n      this.recordMetrics(span, attributeMap[attribute]);\n    }\n  }\n\n  // The logic to record error and fault should be kept in sync with the aws-xray exporter whenever\n  // possible except for the throttle\n  // https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/exporter/awsxrayexporter/internal/translator/cause.go#L121-L160\n  private recordErrorOrFault(spanData: ReadableSpan, attributes: Attributes): void {\n    let httpStatusCode: AttributeValue | undefined = spanData.attributes[SEMATTRS_HTTP_STATUS_CODE];\n    const statusCode: SpanStatusCode = spanData.status.code;\n\n    if (typeof httpStatusCode !== 'number') {\n      httpStatusCode = attributes[SEMATTRS_HTTP_STATUS_CODE];\n    }\n\n    if (\n      typeof httpStatusCode !== 'number' ||\n      httpStatusCode < this.ERROR_CODE_LOWER_BOUND ||\n      httpStatusCode > this.FAULT_CODE_UPPER_BOUND\n    ) {\n      if (SpanStatusCode.ERROR === statusCode) {\n        this.errorHistogram.record(0, attributes);\n        this.faultHistogram.record(1, attributes);\n      } else {\n        this.errorHistogram.record(0, attributes);\n        this.faultHistogram.record(0, attributes);\n      }\n    } else if (httpStatusCode >= this.ERROR_CODE_LOWER_BOUND && httpStatusCode <= this.ERROR_CODE_UPPER_BOUND) {\n      this.errorHistogram.record(1, attributes);\n      this.faultHistogram.record(0, attributes);\n    } else if (httpStatusCode >= this.FAULT_CODE_LOWER_BOUND && httpStatusCode <= this.FAULT_CODE_UPPER_BOUND) {\n      this.errorHistogram.record(0, attributes);\n      this.faultHistogram.record(1, attributes);\n    }\n  }\n\n  private recordLatency(span: ReadableSpan, attributes: Attributes): void {\n    const millisFromSeconds: number = span.duration[0] * this.SECONDS_TO_MILLIS_MULTIPLIER;\n    const millisFromNanos: number = span.duration[1] / this.NANOS_TO_MILLIS_DIVIDER;\n\n    const millis: number = millisFromSeconds + millisFromNanos;\n    this.latencyHistogram.record(millis, attributes);\n  }\n\n  private recordMetrics(span: ReadableSpan, attributes: Attributes): void {\n    // Only record metrics if non-empty attributes are returned.\n    if (Object.keys(attributes).length > 0 && !this.isEc2MetadataApiSpan(attributes)) {\n      this.recordErrorOrFault(span, attributes);\n      this.recordLatency(span, attributes);\n    }\n  }\n\n  public shutdown(): Promise<void> {\n    return this.forceFlush();\n  }\n\n  public forceFlush(): Promise<void> {\n    return this.forceFlushFunction();\n  }\n\n  private isEc2MetadataApiSpan(attributes: Attributes): boolean {\n    return attributes[AWS_ATTRIBUTE_KEYS.AWS_REMOTE_SERVICE] === this.EC2_METADATA_API_IP;\n  }\n}\n"]}