{"version":3,"file":"always-record-sampler.js","sourceRoot":"","sources":["../../src/always-record-sampler.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC;;;AAGtC,kEAA0F;AAE1F;;;;;;;;;;;GAWG;AACH,MAAa,mBAAmB;IAO9B,YAAoB,WAAoB;QACtC,IAAI,WAAW,IAAI,IAAI,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;SACvE;QACD,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACjC,CAAC;IATM,MAAM,CAAC,MAAM,CAAC,WAAoB;QACvC,OAAO,IAAI,mBAAmB,CAAC,WAAW,CAAC,CAAC;IAC9C,CAAC;IASD,YAAY,CACV,OAAgB,EAChB,OAAe,EACf,QAAgB,EAChB,QAAkB,EAClB,UAA0B,EAC1B,KAAa;QAEb,MAAM,yBAAyB,GAAmB,IAAI,CAAC,WAAW,CAAC,YAAY,CAC7E,OAAO,EACP,OAAO,EACP,QAAQ,EACR,QAAQ,EACR,UAAU,EACV,KAAK,CACN,CAAC;QACF,IAAI,yBAAyB,CAAC,QAAQ,KAAK,iCAAgB,CAAC,UAAU,EAAE;YACtE,OAAO,IAAI,CAAC,8BAA8B,CAAC,yBAAyB,CAAC,CAAC;SACvE;QACD,OAAO,yBAAyB,CAAC;IACnC,CAAC;IAED,QAAQ;QACN,OAAO,uBAAuB,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,GAAG,CAAC;IAC/D,CAAC;IAED,8BAA8B,CAAC,MAAsB;QACnD,MAAM,aAAa,GAAmB;YACpC,QAAQ,EAAE,iCAAgB,CAAC,MAAM;YACjC,UAAU,EAAE,MAAM,CAAC,UAAU;YAC7B,UAAU,EAAE,MAAM,CAAC,UAAU;SAC9B,CAAC;QACF,OAAO,aAAa,CAAC;IACvB,CAAC;CACF;AAhDD,kDAgDC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Context, Link, SpanAttributes, SpanKind } from '@opentelemetry/api';\nimport { Sampler, SamplingDecision, SamplingResult } from '@opentelemetry/sdk-trace-base';\n\n/**\n * This sampler will return the sampling result of the provided {@link #rootSampler}, unless the\n * sampling result contains the sampling decision {@link SamplingDecision.NOT_RECORD}, in which case, a\n * new sampling result will be returned that is functionally equivalent to the original, except that\n * it contains the sampling decision {@link SamplingDecision.RECORD}. This ensures that all\n * spans are recorded, with no change to sampling.\n *\n * <p>The intended use case of this sampler is to provide a means of sending all spans to a\n * processor without having an impact on the sampling rate. This may be desirable if a user wishes\n * to count or otherwise measure all spans produced in a service, without incurring the cost of 100%\n * sampling.\n */\nexport class AlwaysRecordSampler implements Sampler {\n  private rootSampler: Sampler;\n\n  public static create(rootSampler: Sampler): AlwaysRecordSampler {\n    return new AlwaysRecordSampler(rootSampler);\n  }\n\n  private constructor(rootSampler: Sampler) {\n    if (rootSampler == null) {\n      throw new Error('rootSampler is null/undefined. It must be provided');\n    }\n    this.rootSampler = rootSampler;\n  }\n\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: SpanAttributes,\n    links: Link[]\n  ): SamplingResult {\n    const rootSamplerSamplingResult: SamplingResult = this.rootSampler.shouldSample(\n      context,\n      traceId,\n      spanName,\n      spanKind,\n      attributes,\n      links\n    );\n    if (rootSamplerSamplingResult.decision === SamplingDecision.NOT_RECORD) {\n      return this.wrapResultWithRecordOnlyResult(rootSamplerSamplingResult);\n    }\n    return rootSamplerSamplingResult;\n  }\n\n  toString(): string {\n    return `AlwaysRecordSampler{${this.rootSampler.toString()}}`;\n  }\n\n  wrapResultWithRecordOnlyResult(result: SamplingResult) {\n    const wrappedResult: SamplingResult = {\n      decision: SamplingDecision.RECORD,\n      attributes: result.attributes,\n      traceState: result.traceState,\n    };\n    return wrappedResult;\n  }\n}\n"]}