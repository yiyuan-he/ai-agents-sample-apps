"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.OTLPUdpSpanExporter = exports.UdpExporter = void 0;
const dgram = require("dgram");
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const otlp_transformer_1 = require("@opentelemetry/otlp-transformer");
const DEFAULT_ENDPOINT = '127.0.0.1:2000';
const PROTOCOL_HEADER = '{"format":"json","version":1}\n';
const DEFAULT_FORMAT_OTEL_TRACES_BINARY_PREFIX = 'T1S';
class UdpExporter {
    constructor(endpoint) {
        this._endpoint = endpoint || DEFAULT_ENDPOINT;
        [this._host, this._port] = this._parseEndpoint(this._endpoint);
        this._socket = dgram.createSocket('udp4');
        this._socket.unref();
    }
    sendData(data, signalFormatPrefix) {
        const base64EncodedString = Buffer.from(data).toString('base64');
        const message = `${PROTOCOL_HEADER}${signalFormatPrefix}${base64EncodedString}`;
        try {
            this._socket.send(Buffer.from(message, 'utf-8'), this._port, this._host, err => {
                if (err) {
                    throw err;
                }
            });
        }
        catch (err) {
            api_1.diag.error('Error sending UDP data: %s', err);
            throw err;
        }
    }
    shutdown() {
        this._socket.close();
    }
    _parseEndpoint(endpoint) {
        try {
            const [host, port] = endpoint.split(':');
            return [host, parseInt(port, 10)];
        }
        catch (err) {
            throw new Error(`Invalid endpoint: ${endpoint}`);
        }
    }
}
exports.UdpExporter = UdpExporter;
class OTLPUdpSpanExporter {
    constructor(endpoint, _signalPrefix) {
        this._endpoint = endpoint || DEFAULT_ENDPOINT;
        this._udpExporter = new UdpExporter(this._endpoint);
        this._signalPrefix = _signalPrefix || DEFAULT_FORMAT_OTEL_TRACES_BINARY_PREFIX;
    }
    export(spans, resultCallback) {
        const serializedData = otlp_transformer_1.ProtobufTraceSerializer.serializeRequest(spans);
        if (serializedData == null) {
            return;
        }
        try {
            this._udpExporter.sendData(serializedData, this._signalPrefix);
            return resultCallback({ code: core_1.ExportResultCode.SUCCESS });
        }
        catch (err) {
            api_1.diag.error('Error exporting spans: %s', err);
            return resultCallback({ code: core_1.ExportResultCode.FAILED });
        }
    }
    forceFlush() {
        return Promise.resolve();
    }
    /** Shutdown exporter. */
    shutdown() {
        return new Promise((resolve, reject) => {
            try {
                this._udpExporter.shutdown();
                resolve();
            }
            catch (error) {
                reject(error);
            }
        });
    }
}
exports.OTLPUdpSpanExporter = OTLPUdpSpanExporter;
//# sourceMappingURL=otlp-udp-exporter.js.map